<div class="container">
  <h2>current state</h2>
  <div id="diagram">

  </div>
</div>

<script>
  var chart_seen = false;

  var cachedWidth = $(window).width();

	data = [
    {
      name: "bereits erhalten",
      value: "200",
      color: "#90EE90"
    },
    {
      name: "noch benÃ¶tigt",
      value: "100",
      color: "#FF4500"
    },
    {
      name: "total",
      value: "300",
      color: "steelblue"
    }
  ];


	//drawTree('#diagram', data)

  //$( "#diagram" ).height(height);

  createGrid('#diagram', data);
  //drawTree('#diagram', data)

  function createGrid(container, data){

    margin = ({top: 30, right: 0, bottom: 30, left: 50})
    width = $( "#diagram" ).width();//500
    barHeight = 100;
    height = Math.ceil((data.length + 0.1) * barHeight) + margin.top + margin.bottom
    fontSize = 18;

    x = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.value)])
        .range([margin.left, width - 70])

      format = x.tickFormat(10, data.format)

    y = d3.scaleBand()
      .domain(d3.range(data.length))
      .rangeRound([margin.top, height - margin.bottom])
      .padding(0.1)

    xAxis = g => g
        .attr("transform", `translate(0,${margin.top})`)
        .call(d3.axisTop(x).ticks(width/(width/3)))
        .call(g => g.select(".domain").remove())
        .attr("font-size", fontSize);

    yAxis = g => g
        .attr("transform", `translate(${margin.left},0)`)
        //.call(d3.axisLeft(y).tickFormat, "Snow")
        //.call(d3.axisLeft(y).tickFormat(i => data[i].name).tickSizeOuter(0))
        //.call(d3.axisLeft(y).tickFormat(i => data[i].name).tickSizeOuter(0))
        //.call(d3.axisLeft(y).tickFormat(i => data[i].name).tickSizeOuter(0))
        .call(d3.axisLeft(y).tickFormat(i => data[i].name).tickSizeOuter(0))
        //.call(d3.axisLeft(y).tickFormat(function(d) {return 'yo';}))
        //.call(wrap)
        .attr("font-size", fontSize)
        .attr("class", "label-on-y-axis");

    const svg = d3.select(container).append('svg')
      .attr("viewBox", [-margin.left, -margin.top, width, height])
      .attr("preserveAspectRatio", "xMinYMin meet")
      .style("font", "18px sans-serif")
      .style("user-select", "none");


      svg.append("g")
        .selectAll("rect")
        .data(data)
        .join("rect")
          .attr("x", x(0))
          .attr("y", (d, i) => y(i))
        //  .attr("width", d => x(d.value) - x(0))
          .attr("height", y.bandwidth())
          .attr("fill", "purple");

      svg.append("g")
          .attr("fill", "white")
          .attr("text-anchor", "end")
          .attr("font-family", "sans-serif")
          .attr("font-size", fontSize)
        .selectAll("text")
        .data(data)
        .join("text")
          .attr("x", d => x(d.value))
          .attr("y", (d, i) => y(i) + y.bandwidth() / 2)
          .attr("dy", "0.35em")
          .attr("dx", -4)
          .text(d => format(d.value))
        .call(text => text.filter(d => x(d.value) - x(0) < 20) // short bars
          .attr("dx", +4)
          .attr("fill", "black")
          .attr("text-anchor", "start"));

      svg.append("g")
          .call(xAxis);

      svg.append("g")
          .call(yAxis);

      //svg.selectAll('text').each(insertLinebreaks);

      //make labels wrap
      svg.selectAll(".label-on-y-axis .tick text")
        .call(wrap, 100);

      svg.selectAll(".label-on-y-axis tspan").attr("dx", -10);

      return svg.node();
  }

	function animateBars(container, data){
    console.log("start animation");

    margin = ({top: 30, right: 0, bottom: 30, left: 50})
    width = $( "#diagram" ).width();//500
    barHeight = 100
    height = Math.ceil((data.length + 0.1) * barHeight) + margin.top + margin.bottom
    fontSize = 18

  var svg = d3.select(container).select("svg")
    // Animation
  svg.selectAll("rect")
    .transition()
    .duration(3000)
    //.attr("y", function(d) { return y(d.value); })
    //.attr("width", function(d) { return height - y(d.value); })
  //  .attr("x", x(0))
  //  .attr("y", (d, i) => y(i))
    .attr("width", d => x(d.value) - x(0))
    //.attr("height", y.bandwidth())
    .style("fill", function(d) { return d.color; })
    .delay(function(d,i){return(i*300)})

    return svg.node();

	}

  function wrap(text, width) {
    text.each(function() {
      var text = d3.select(this),
          words = text.text().split(/\s+/).reverse(),
          word,
          line = [],
          lineNumber = 0,
          lineHeight = 1.1, // ems
          y = text.attr("y"),
          dy = parseFloat(text.attr("dy")),
          tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
      while (word = words.pop()) {
        line.push(word);
        tspan.text(line.join(" "));
        if (tspan.node().getComputedTextLength() > width) {
          line.pop();
          tspan.text(line.join(" "));
          line = [word];
          tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
        }
      }
    });
  }

  function isElementInViewport(el) {

      // Special bonus for those using jQuery
      if (typeof jQuery === "function" && el instanceof jQuery) {
          el = el[0];
      }

      var rect = el.getBoundingClientRect();

      return (
        rect.bottom >= 0 &&
        rect.right >= 0 &&
        rect.top + 200 <= (window.innerHeight || document.documentElement.clientHeight) &&
        rect.left <= (window.innerWidth || document.documentElement.clientWidth)
      );
  }

  $(window).on("load scroll",function(e){
    // define the function here
    if((chart_seen == false) && isElementInViewport(document.getElementById("diagram"))){
      //$("#diagram").empty();
      animateBars('#diagram', data)
      chart_seen = true;
    }
  });

  $( window ).resize(function() {

    var newWidth = $(window).width();
    if(newWidth !== cachedWidth){
      console.log("resize!");
      $("#diagram").empty();
      createGrid('#diagram', data);
      animateBars('#diagram', data);
      cachedWidth = newWidth;
    }

  });

</script>
